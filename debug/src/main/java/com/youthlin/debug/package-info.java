/**
 * <h1>《深入理解 Java 虚拟机》 <small>周志明</small></h1>
 * <h2>第九章 字节码执行引擎-类加载及执行子系统的案例与实战</h2>
 * <h3>实战:自己动手实现远程执行功能</h3>
 * 不知道读者在做程序维护的时候是否遇到过这类情形:排查问题的过程中,想查看内存中的一些参数值,
 * 却又没有方法把这些值输出到界面或日志中,又或者定位到某个缓存数据有问题 ,但缺少缓存的统一管理界面,
 * 不得不重启服务才能清理这个缓存。类似的需求有一个共同的特点,那就是只要在服务中执行一段程序代码,
 * 就可以定位或排除问题,但就是偏偏找不到可以让服务器执行临时代码的途径,
 * 这时候就会希望Java服务器中也有提供类似Groovy Console的功能。
 * <p>
 * JDK 1.6之后提供了Compiler API , 可以动态地编译Java程序,虽然这样达不到动态语言的灵活度,
 * 但让服务器执行临时代码的需求就可以得到解决了。在JDK 1.6之前 ,也可以通过其他方式来做到,
 * 譬如写一个JSP文件上传到服务器,然后在浏览器中运行它,
 * 或者在服务端程序中加入一个BeanShell Script、JavaScript等的执行引擎(如Mozilla Rhino)去执行动态脚本。
 * 在本章的实战部分,我们将使用前面学到的关于类加载及虚拟机执行子系统的知识去实现在服务端执行临时代码的功能。
 * <p>
 * <h3>目标</h3>
 * 首先 ,在实现“在服务端执行临时代码”这个需求之前,先来明确一下本次实战的具体目标 ,
 * 我们希望最终的产品是这样的:
 * <ul>
 * <li>不依赖JDK版本,能在目前还普遍使用的JDK中部署,也就是使用JDK1.4〜JDK1.7都可以运行。</li>
 * <li>不改变原有服务端程序的部署,不依赖任何第三方类库。</li>
 * <li>不侵入原有程序,即无须改动原程序的任何代码,也不会对原有程序的运行带来任何影响。</li>
 * <li>考到BeanShell Script或JavaScript等脚本编写起来不太方便,“临时代码”需要直接支持Java语言。</li>
 * <li>“临时代码”应当具备足够的自由度,不需要依赖特定的类或实现特定的接口。这里写的 是“不需要”而不是“不可以”,
 * 当“临时代码”需要引用其他类库时也没有限制,只要服务端程序能使用的,临时代码应当都能直接引用。</li>
 * <li>“临时代码” 的执行结果能返回到客户端,执行结果可以包括程序中输出的信息及拋出的异常等。</li>
 * </ul>
 * 看完上面列出的目标,你觉得完成这个需求需要做多少工作呢?也许答案比大多数人所想的都要简单一些:5个类,
 * 250行代码(含注释),大约一个半小时左右的开发时间就可以了 ,现在就开始编写程序吧!
 * <p>
 * <p>
 * <h3>思路</h3>
 * 在程序实现的过程中,我们需要解决以下3个问题:
 * <ul>
 * <li>如何编译提交到服务器的Java代码?</li>
 * <li>如何执行编译之后的Java代码?</li>
 * <li>如何收集Java代码的执行结果?</li>
 * </ul>
 * 对于第一个问题,我们有两种思路可以选择,一种是使用tools.jar包 (在SunJDK/lib目录下)中的
 * com.sun.tools.javac.Main类来编译Java文件,这其实和使用Javac命令编译是一样的。
 * 这种思路的缺点是引入了额外的JAR包 ,而且把程序“綁死”在Sun的JDK上了,要部署到其他公司的JDK中还得把tools.jar带上
 * (虽然JRockit和J9虚拟机也有这个JAR包,但它总不是标准所规定必须存在的)。另外一种思路是直接在客户端编译好,
 * 把字节码而不是Java代码传到服务端,这听起来好像有点投机取巧,一般来说确实不应该假定客户端一定具有编译代码的能力,
 * 但是既然程序员会写Java代码去给服务端排查问题,那么很难想象他的机器上会连编译Java程序的环境都没有。
 * <p>
 * 对于第二个问题,简单地一想:要执行编译后的Java代码,让类加载器加载这个类生成一个Class对象 ,
 * 然后反射调用一下某个方法就可以了(因为不实现任何接口,我们可以借用一下Java中人人皆知的“main() ”方法)。
 * 但我们还应该考虑得更周全些:一段程序往往不是编写、运行一次就能达到效果,同一个类可能要反复地修改、提交、执行。
 * 另外,提交上去的类要能访问服务端的其他类库才行。还有 ,既然提交的是临时代码,那提交的Java类在执行完后就应当能卸载和回收。
 * <p>
 * 最后的一个问题,我们想把程序往标准输出(Systemout)和标准错误输出( Systemerr ) 中打印的信息收集起来,
 * 但标准输出设备是整个虚拟机进程全局共享的资源,如桌使用System.setOut()/System.setErr()方法
 * 把输出流重定向到自己定义的PrintStream对象上固然可以收集输出信息,但也会对原有程序产生影响:
 * 会把其他线程向标准输出中打印的信息也收集了。虽然这些并不是不能解决的问题,不过为了达到完全不影响原程序的目的 ,
 * 我们可以采用另外一种办法,即<strong>直接在执行的类中把对System.out的符号引用替换为我们准备的PnntStream的符号引用</strong>,
 * 依赖前面学习的知识,做到这一点并不困难。
 * <p>
 * 创建: youthlin.chen
 * 时间: 2018-03-14 20:22
 *
 * @link http://blog.csdn.net/coslay/article/details/49564789
 */
package com.youthlin.debug;
